#include<iostream>
#include<string>
using namespace std;

/*
	new 方法 是在堆区开辟一块内存，用来存放数据
	new 方法 返回的是存放该数据的地址
	如何接收：
		因为返回的是地址，因此定义一个指针变量去接收该地址
		再解引用将这个指针指向的值拿出来
	堆区的数据是由程序员管理开辟，管理释放

*/

int* test() {
	int* p = new int (10);
	return p;
}
/*
	在堆区创建一个数组
	new int(10) 小括号是创建一个元素
	new int[10] 中括号表示创建一个数组，是十个元素

*/

void test02() {
	int* array = new int[10]; // 在堆区创建一个数组
	for (int i = 0; i < 10; i++) {
		array[i] = i +  100; // 对数组进行赋值操作
	}
	for (int i = 0; i < 10; i++) {
		cout << array[i] << endl;
	}
	delete[] array; // 释放数组的时候，需要加一个中括号
}


/*
	引用：就是给一个变量起别名
	数据类型 &别名 = 原来变量的名字
	注意：如果在引用的时候对该变量的值进行修改，那么原始的值也会被修改的
*/

int main() {
	int *p = test();
	cout << *p << endl;
	cout << *p << endl;
	cout << *p << endl;

	test02();
	int a = 10; // 变量的原名
	int& b = a; // 引用
	/*
		引用注意事项：
			（1）必须进行初始化 int &b = a； 是必须进行初始化的
			（2）初始化后不可以更改
	*/
	cout << "**************************" << endl;
	cout << "******引用的知识点*******" << endl;
	cout << "a = " << a << endl;
	cout << "b = " << b << endl;

	b = 20; // 在引用的时候修改变量名字
	cout << "a = " << a << endl;
	cout << "b = " << b << endl;
	

	delete p; // 释放该段内存
	// cout << *p << endl;  // 无法访问是因为我们已经释放了这段内存
	/*
		引用作为函数的传递参数：
			可以实现和指针类似的功能，但是会比指针稍微简单点
			不过，本质应该是相同的
			都是指向那个存放变量的地址

		引用的本质就是一个指针：const指针


		函数重载：
			函数名相同，在同一个作用域下
			函数的参数数目、类型等可以不想同
	
	*/

}